# Курсовая работа Конструирование программы, реализующей игру-головоломку «Gappy»

## Скачивание, компиляция и запуск:

Скачиваем ZIP-файл проекта с GitHubю
Далее распоковываем ZIP в любую удобную папку. Открываем командную строку (cmd).
**Команды для перехода по папкам в cmd:**
    - `cd "NAME"` - открыть папку;
    - `dir` - вывести в cmd каталог, в которым Вы находитесь;
    - `gcc` - вызвать компилятор (GNU Compiler Collection);
    - `-o "NAME"` - указать имя файла, с которым сохранится скомпилированная программа;
    - `-fexec-charset=cp1251` - руссификатор (стандартаня кодировка Windows cp1251);
    - `start` - запуск программ, команд, открытия файлов или папок в отдельном окне.

Когда Вы в консоли перешли в папку проекта, то необходимо ввести следующую команду:         
`gcc main.c Check_rule.c -o Game -fexec-charset=cp1251`         
Она скомпилирует код и создаст файл "Game.exe" в папке проекта.       
Далее необходимо использовать команду `start Game.exe`, результатом которой станет открытие нового окна с программой данного проекта.

## Постановка задач:
Сгенерировать игровые поля для головоломок, вывести их для визуальной проверки и при успешном отборе сохранить в файл для дальнейшего использования.
1)	Генерация игрового поля  с проверкой решаемости головоломки
2)	Отрисовка игрового поля ACSI-символами (w_char+)
3)	Запись в файл в виде удобном для работы игры-головоломки формате

## Алгоритм:
1.  **Инициализация и настройка:**
    *   Установка русской локализации.
    *   Объявление переменных для игровых полей и флагов.

2.  **Главное меню и навигация:**
    *   Вывод приветствия и меню.
    *   Если выбраны правила: вывод инструкции по механике игры и интерфейсу, затем повторный выбор.

3.  **Генерация игрового поля:**
    *   Циклический вызов функции `rand_generation` до тех пор, пока не будет создано валидное поле.
    *   Вычисление числовых подсказок (количества пустых клеток между точками) и запись их в массив `field_C_R`.
    *   Подготовка чистого игрового поля для пользователя.

4.  **Основной игровой цикл:**
    *   Очистка экрана и вывод актуального состояния игрового поля с подсказками.
    *   **Ожидание ввода данных от пользователя:**
        *   Если введены **специальные коды**:
            *   *Смена режима:* переключение между символом «заполненная ячейка» и «пустая ячейка».
            *   *Очистка:* сброс всех ходов игрока.
            *   *Проверка:* сравнение текущего состояния поля игрока с правилами/подсказками.
        *   Если введены **координаты (X Y)**: установка выбранного символа в соответствующую ячейку массива.

5.  **Завершение игры:**
    *   В случае успешной проверки правильности решения:
        *   Вывод поздравления.
        *   Предложение сохранить условия головоломки (числовые поля) в текстовый файл `Puzzle_fields.txt`.
        *   Завершение программы.

## Процесс работы программы:

![Блок-схема](./Структура.png)

## Структура проекта

Kursach/

├── src/

│   ├── Check_rule.c

│   ├── Check_rule.h

│   ├── main.c

└── └── README.md


## Основные функции:

### 1. `bool check_o(const char* arr, int size, int r, int c, int mode);`
- **Назначение**: проверяет ячейки на наличие заполненной ячейки              
- **Параметры**:            
   `arr - двумерный массив, где идёт проверка;`
   `size - размер массива arr;`
   `r - индекс "строки" ячейки, вокруг которой идёт проверка;`
   `c - индекс "столбца" ячейки, вокруг которой идёт проверка;`
   `method - режим проверки;`
- **Возвращает**: true, если ячейка не была найдена; иначе false. 

### 2. `bool rand_generation(char* arr, int size, int* amount_r, int* amount_c);`
- **Назначение**: генерирует поле с заполненными точками по правилам "игры"
- **Параметры**: 
    `arr - массив, который заполняется;`
    `size - размер массива arr;`
    `amount_r - массив для хранения точек в "строке";`
    `amount_c - массив для хранения точек в "столбце";`
- **Возвращает**: true, если массив успешно сгенерировалось;  иначе false.

### 3. `bool rand_generation(char* arr, int size, int* amount_r, int* amount_c);`
- **Назначение**: проверяет относительно полученной точки правила:
      - только 2 точки в строке/столбце массива;
      - кол-во промежутков между точками соответствует цифре напротив строки/столбца.
- **Параметры**: 
   `arr_u - массив, который заполнен пользователем;`
   `size - размер массива arr;`
   `field_С_R - массив, в ячейки которого записаны кол-во промежутков в строке/столбце массива arr.`
- **Возвращает**: true, если заполнение пользователя соответствует правилам;  иначе false.

### 4. `bool cheak_line(const char* arr_u, int size, const int* field_C_R, int i, int j);`
- **Назначение**: Проверяет относительно полученной точки правила:
        - только 2 точки в строке/столбце;
        - кол-во промежутков между точками соответствует цифре напротив строки/столбца;
        - вокруг точки нет других точек (в том числе по диагонали).
- **Параметры**: 
   `arr_u - массив, который заполнен пользователем;`
   `@param size - размер массива arr;`
   `@param field_С_R - массив, в ячейки которого записаны кол-во промежутков в строке/столбце`
   `@param i - индекс "строки" ячейки, относительно которой идёт проверка;`
   `@param j - индекс "столбца" ячейки, относительно которой идёт проверка;`
- **Возвращает**: true, если заполнение пользователя соответствует правилам;  иначе false.

## Контрольный пример:

При случайной генерации полей получились поля:
- Столбцы: 3 3 3 4 5 1 6 1 1 
- Строки:  1 1 1 1 1 1 3 4 4 
Введя последовательно 1 2  1 6  2 4  2 8  3 2  3 6  4 4  4 9  5 1  5 7  6 3  6 5  7 1  7 8  8 3  8 5  9 7  9 9, получили верно решённую головоломку.
(./ot.png)
